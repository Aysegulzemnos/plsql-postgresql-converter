group PLSQLPrinterTemplates;

string_literal(val) ::= "<val>"

create_function_body(
  is_replace, name_parts, arguments,
  return_type, add_clauses, is_pipelined, body
) ::= <<
create<if (is_replace)>or replace<endif> function <name_parts; separator=".">
<if (arguments)>(<arguments; separator=",\n">)<endif>
return <return_type>
<add_clauses; separator=" ">
<if (is_pipelined)>pipelined<endif>
as
<body>;
>>

parameter(
  name, is_in, is_out, is_inout, is_nocopy, type
) ::= <<
<name><if (is_in)> IN<elseif (is_out)> OUT<elseif (is_inout)> IN OUT<endif><if (is_nocopy)> NOCOPY<endif> <type>
>>

base_type_spec_precision(
  size1, size2, is_byte, is_char
) ::= <<
(<size1><if (is_byte)> byte<elseif (is_char)> char<endif><if (size2)>, <size2><endif>)
<endif>
>>

base_type_spec(
  baseName, precision, is_with_time_zone, is_time_zone_local
) ::= <<
<baseName><precision><if (is_with_time_zone)>
 with<if (is_time_zone_local)> local<endif> time zone
<endif>
>>

body(
  bodyLabel, statements, exception_clause
) ::= <<
begin
  <statements>
<exception_clause>
end<if (bodyLabel)> <bodyLabel><endif>
>>

seq_of_statements(statements) ::= <<
<statements:{statement|<statement>;}; separator="\n">
>>

label_declaration(name) ::= "\<\<<name>\>\>"

return_statement(expression) ::= "return<if (expression)> <expression><endif>"

general_element(parts) ::= "<parts>"

function_argument(valueExpr, name) ::= "<if (name)><name> => <endif><valueExpr>"

function_arguments(arguments) ::= <<
(<arguments; separator=", ">)
>>

expression_element_generic_binop(op, arg1, arg2) ::= "(<arg1>) <op> (<arg2>)"

for_loop(loopDefinition, statements) ::= <<
for <loopDefinition> loop
  <statements>
end loop
>>

loopDefinition_bounds(indexVar, isReverse, lowerBound, upperBound) ::= <<
<indexVar> in<if (isReverse)> reverse<endif> <lowerBound>..<upperBound>
>>

select_statement(query_partitioning_clause, subquery, order_by_clause, for_update_clause) ::= <<
<if (query_partitioning_clause)><query_partitioning_clause><endif>
<subquery><if (order_by_clause)>

<order_by_clause>
<endif>
<if (for_update_clause)>

<for_update_clause>
<endif>
>>

subquery(subquery_basic_elements, subquery_operation_parts) ::= <<
<subquery_basic_elements><if (subquery_operation_parts)>
<subquery_operation_parts; separator="\n">
<endif>
>>

subquery_operation_part(operator, is_all, subquery_basic_elements) ::= <<
<operator><if (is_all)> all<endif>
<subquery_basic_elements>
>>

in_parens(val) ::= "(<val>)"

query_block(
  is_distinct, is_unique, is_all, is_asterisk, selected_elements,
  into_clause, from_clause, where_clause, hierarchical_query_clause, group_by_clause, model_clause
) ::= <<
select <if (is_distinct)>
distinct 
<elseif (is_unique)>
unique
<elseif (is_all)>
all
<endif>
<if (is_asterisk)>
*
<else>
<selected_elements; separator=",\n  ">
<endif>
<if (into_clause)>
<into_clause>
<endif>

<from_clause><if (where_clause)>

<where_clause>
<endif><if (hierarchical_query_clause)>

<hierarchical_query_clause>
<endif><if (group_by_clause)>

<group_by_clause>
<endif><if (model_clause)>

<model_clause>
<endif>
>>

alias(name) ::= "as <name>"

selected_element(expression, alias) ::= "<expression><alias>"

from_clause(table_refs) ::= <<
from <table_refs; separator=",\n  ">
>>

table_ref(table_ref_aux, join_clauses) ::= <<
<table_ref_aux><if (join_clauses)>

<join_clauses; separator="\n">
<endif>
>>

join_clause(qpc1, is_cross, is_natural, is_inner, is_left, is_right, is_full, table_ref_aux, qpc2, join_on_part, join_using_part) ::= <<
<if (qpc1)>
<qpc1>
<endif>
<if (is_cross)>
cross
<else>
<if (is_natural)>
natural
<endif>
<if (is_inner)>
inner
<elseif (is_left)>
left
<elseif (is_right)>
right
<elseif (is_full)>
full
<endif>
<endif>
join <table_ref_aux> <if (qpc2)>
<qpc2>
<endif>
<if (join_on_part)><join_on_part><else><join_using_part><endif>
>>