group PLSQLPrinterTemplates;

string_literal(val) ::= "<val>"

create_function_body(
  is_create, is_replace, name_parts, arguments,
  return_type, add_clauses, is_pipelined, block
) ::= <<
<if (is_create)>create<if (is_replace)> or replace<endif> <endif>function <name_parts; separator="."><if (arguments)>
  (<arguments; separator=",\n">)<endif>
return <return_type>
<add_clauses; separator=" ">
<if (is_pipelined)>pipelined<endif>

is
<block>
>>

parameter(
  name, is_in, is_out, is_inout, is_nocopy, type, default_value_part
) ::= <<
<name><if (is_in)>
 IN<endif><if (is_out)> OUT<endif><if (is_inout)> IN OUT
<endif><if (is_nocopy)>
 NOCOPY
<endif> <type><if (default_value_part)> <default_value_part><endif>
>>

default_value_part(expression) ::= "default <expression>"

base_type_spec_precision(
  size1, size2, is_byte, is_char
) ::= <<
(<size1><if (is_byte)> byte<elseif (is_char)> char<endif><if (size2)>, <size2><endif>)
<endif>
>>

base_type_spec(
  baseName, precision, is_with_time_zone, is_time_zone_local
) ::= <<
<baseName><precision><if (is_with_time_zone)>
 with<if (is_time_zone_local)> local<endif> time zone
<endif>
>>

body(
  bodyLabel, statements, exception_clause
) ::= <<
begin
  <statements>
<exception_clause>
end<if (bodyLabel)> <bodyLabel><endif>
>>

seq_of_statements(statements) ::= <<
<statements:{statement|<statement>;}; separator="\n">
>>

labeled_statement(name, statement) ::= <<
\<\<<name>\>\>
<statement>
>>

return_statement(expression) ::= "return<if (expression)> <expression><endif>"

null_statement() ::= "null"

case_statement_searched(case_when_parts, case_else_part) ::= <<
case
  <case_when_parts; separator="\n"><if (case_else_part)>
  
  <case_else_part><endif>
end
>>

case_when_part_statements(condition, seq_of_statements) ::= <<
when <condition>
then
  <seq_of_statements>
>>

case_when_part_expression(condition, expression) ::= <<
when <condition> then <expression>
>>

case_else_part_statements(seq_of_statements) ::= <<
else
  <seq_of_statements>
>>

case_else_part_expression(expression) ::= <<
else <expression>
>>

general_element(parts) ::= "<parts>"

function_argument(valueExpr, name) ::= "<if (name)><name> => <endif><valueExpr>"

function_arguments(arguments) ::= <<
(<arguments; separator=", ">)
>>

expression_element_generic_binop(op, arg1, arg2) ::= "(<arg1>) <op> (<arg2>)"
expression_element_generic_suffix_unary_op(op, arg) ::= "(<arg>) <op>"
expression_element_generic_prefix_unary_op(op, is_spaced, arg) ::= "<op><if (is_spaced)> <endif>(<arg>)"
expression_element_cursor_op(cursor_name, op) ::= "<cursor_name><op>"
expression_element_in(expr, in_elements) ::= "<expr> in <in_elements>"
expression_element_not_in(expr, in_elements) ::= "<expr> not in <in_elements>"
expression_element_prior(expr) ::= "prior <expr>"
expression_element_dot_star(tableview_name) ::= "<tableview_name>.*"

standard_function_count(is_distinct, is_unique, is_all, is_asterisk, expression, over_clause) ::= <<
count(<if (is_distinct)>
distinct <elseif(is_unique)>unique <elseif(is_all)>all <endif><if (is_asterisk)>*<else><expression>
<endif>)<if (over_clause)> <over_clause><endif>
>>

standard_function_enabling_over(function_name, function_arguments, over_clause) ::= <<
<function_name><function_arguments><if (over_clause)> <over_clause><endif>
>>

for_loop(loopDefinition, statements) ::= <<
for <loopDefinition> loop
  <statements>
end loop
>>

loopDefinition_bounds(indexVar, isReverse, lowerBound, upperBound) ::= <<
<indexVar> in<if (isReverse)> reverse<endif> <lowerBound>..<upperBound>
>>

loopDefinition_select(indexVar, select_statement) ::= <<
<indexVar> in
(
  <select_statement>
)
>>

select_statement(query_partitioning_clause, subquery, order_by_clause, for_update_clause) ::= <<
<if (query_partitioning_clause)><query_partitioning_clause><endif>
<subquery><if (order_by_clause)>

<order_by_clause>
<endif>
<if (for_update_clause)>

<for_update_clause>
<endif>
>>

subquery(subquery_basic_elements, subquery_operation_parts) ::= <<
<subquery_basic_elements><if (subquery_operation_parts)>
<subquery_operation_parts; separator="\n">
<endif>
>>

subquery_operation_part(operator, is_all, subquery_basic_elements) ::= <<
<operator><if (is_all)> all<endif>
<subquery_basic_elements>
>>

in_parens(val) ::= "(<val>)"

query_block(
  is_distinct, is_unique, is_all, is_asterisk, selected_elements,
  into_clause, from_clause, where_clause, hierarchical_query_clause, group_by_clause, model_clause
) ::= <<
select <if (is_distinct)>
distinct 
<elseif (is_unique)>
unique
<elseif (is_all)>
all
<endif>
<if (is_asterisk)>
*
<else>
<selected_elements; separator=",\n  ">
<endif>
<if (into_clause)>

<into_clause>
<endif>

<from_clause><if (where_clause)>

<where_clause>
<endif><if (hierarchical_query_clause)>

<hierarchical_query_clause>
<endif><if (group_by_clause)>

<group_by_clause>
<endif><if (model_clause)>

<model_clause>
<endif>
>>

column_alias(name) ::= "as <name>"
table_alias(name) ::= "<name>"

selected_element(expression, alias) ::= "<expression><if (alias)> <alias><endif>"

from_clause(table_refs) ::= <<
from <table_refs; separator=",\n  ">
>>

table_ref(table_ref_aux, join_clauses) ::= <<
<table_ref_aux><if (join_clauses)>

<join_clauses; separator="\n">
<endif>
>>

join_clause(qpc1, is_cross, is_natural, is_inner, is_left, is_right, is_full, table_ref_aux, qpc2, join_on_part, join_using_part) ::= <<
<if (qpc1)>
<qpc1>
<endif>
<if (is_cross)>
cross
<else>
<if (is_natural)>
natural
<endif>
<if (is_inner)>
inner
<elseif (is_left)>
left
<elseif (is_right)>
right
<elseif (is_full)>
full
<endif>
<endif>
join <table_ref_aux> <if (qpc2)>
<qpc2>
<endif>
<if (join_on_part)><join_on_part><else><join_using_part><endif>
>>

table_ref_aux(is_only, dml_table_expression_clause, pivot_clause, unpivot_clause, flashback_query_clause, alias) ::= <<
<if (is_only)>
only(<dml_table_expression_clause>)
<else>
<dml_table_expression_clause><if (pivot_clause)> <pivot_clause><elseif (unpivot_clause)> <unpivot_clause><endif>
<endif><if (flashback_query_clause)> <flashback_query_clause><endif><if (alias)> <alias><endif>
>>

dml_table_expression_clause_direct(table_or_view_name, sample_clause) ::= <<
<table_or_view_name><if (sample_clause)> <sample_clause><endif>
>>

tableview_name(ids, link_name, partition_extension_clause) ::= <<
<ids; separator="."><if (link_name)>@<link_name><endif><if (partition_extension_clause)><partition_extension_clause><endif>
>>

dml_table_expression_clause_select(select_statement, subquery_restriction_clause) ::= <<
(<select_statement><if (subquery_restriction_clause)>

<subquery_restriction_clause>
<endif>)
>>

join_on_part(expression) ::= "on <expression>"

where_clause(expression) ::= "where <expression>"

order_by_clause(is_siblings, elements) ::= <<
order<if (is_siblings)> siblings<endif> by <elements; separator=", ">
>>

order_by_elements(expression, is_asc, is_desc, is_nulls_first, is_nulls_last) ::= <<
<expression><if (is_asc)> asc<elseif (is_desc)> desc<endif><if (is_nulls_first)> nulls first<elseif (is_nulls_last)> nulls last<endif>
>>

create_package_spec(is_replace, name, invoker_rights_clause, items) ::= <<
create<if (is_replace)> or replace<endif> package <name><if (invoker_rights_clause)>

<invoker_rights_clause>
<endif>

is
  <items; separator="\n\n">
end;
>>

dotted_name(ids) ::= <<
<ids; separator=".">
>>

procedure_spec(name, arguments) ::= <<
procedure <name><if (arguments)>(
  <arguments; separator=",\n">)<endif>;
>>

function_spec(name, arguments, return_type, is_pipelined, is_result_cache, is_deterministic) ::= <<
function <name><if (arguments)>(
  <arguments; separator=",\n">)<endif>
return <return_type><if (is_pipelined)> pipelined<endif><if (is_result_cache)> result_cache<endif><if (is_deterministic)> deterministic<endif>;
>>

typespec_custom(name, is_ref, is_percent_rowtype, is_percent_type) ::= <<
<if (is_ref)>ref <endif><name><if (is_percent_rowtype)>%rowtype<elseif (is_percent_type)>%type<endif>
>>

create_package_body(is_replace, name, items, init_section_seq_of_statements, init_section_exception_clause) ::= <<
create<if (is_replace)> or replace<endif> package body <name>
is
  <items; separator="\n\n"><if (init_section_seq_of_statements)>

begin
  <init_section_seq_of_statements>
<init_section_exception_clause>
<endif>

end;
>>

create_procedure_body(is_create, is_replace, name, arguments, invoker_rights_clause, impl) ::= <<
<if (is_create)>create<if (is_replace)> or replace<endif> <endif>procedure <name><if (arguments)>(
  <arguments; separator=",\n">)<endif><if (invoker_rights_clause)>

<invoker_rights_clause>
<endif>

is
<impl>
>>

create_procedure_body_impl_external() ::= "external"

block(declare_spec, body) ::= <<
<if (declare_spec)>
declare
  <declare_spec:{v|<v>
}>
<endif>
<body>;
>>

variable_declaration(name, type, is_constant, is_not_null, default_value_part) ::= <<
<name><if (is_constant)> constant<endif> <type><if (is_not_null)> not null<endif><if (default_value_part)> <default_value_part><endif>;
>>

table_type_dec(name, impl) ::= <<
type <name> is <impl>;
>>

varray_type_def(limit_expression, element_type, is_not_null) ::= <<
varray(<limit_expression>) of <element_type><if (is_not_null)> not null<endif>
>>

table_type_dec_table_of(type_spec, table_indexed_by_part, is_not_null) ::= <<
table of <type_spec><if (table_indexed_by_part)> <table_indexed_by_part><endif><if (is_not_null)> not null<endif>
>>

table_indexed_by_part(type_spec) ::= <<
indexed by <type_spec>
>>

subtype_declaration(name, type_spec, range, is_not_null) ::= <<
subtype <name> is <type_spec><if (range)> <range><endif><if (is_not_null)> not null<endif>;
>>

subtype_range(low_bound, high_bound) ::= <<
range <low_bound>..<high_bound>
>>
    
record_type_dec_record(name, field_specs) ::= <<
type <name> is record (
  <field_specs; separator=",\n">);
>>
    
record_type_dec_refcursor(name, type_spec) ::= <<
type <name> is ref cursor<if (type_spec)> return <type_spec><endif>;
>>

field_spec(name, type_spec, is_not_null, default_value_part) ::= <<
<name><if (type_spec)> <type_spec><endif><if (is_not_null)> not null<endif><if (default_value_part)> <default_value_part><endif>
>>

pragma_declaration(impl) ::= "pragma <impl>;"

pragma_declaration_impl_serially_reusable() ::= "serially_reusable"
pragma_declaration_impl_serially_autonomous_transaction() ::= "autonomous_transaction"
pragma_declaration_impl_serially_exception_init(name, numeric) ::= "exception_init (<name>, <numeric>)"
pragma_declaration_impl_serially_inline(id, expression) ::= "inline (<id>, <expression>)"
pragma_declaration_impl_serially_restrict_references(arg1, restArgs) ::= <<
restrict_references (<arg1><restArgs:{v|, <v>}>)
>>

single_table_insert(insert_into_clause, values_clause, static_returning_clause, select_statement, error_logging_clause) ::= <<
insert <insert_into_clause>
<if (values_clause)>
<values_clause><if (static_returning_clause)>

<static_returning_clause>
<endif>
<else>
<select_statement>
<endif><if (error_logging_clause)>

<error_logging_clause>
<endif>
>>

insert_into_clause(general_table_ref, columns) ::= <<
into <general_table_ref><if (columns)>(<columns; separator=", ">)<endif>
>>

general_table_ref(is_only, dml_table_expression_clause, table_alias) ::= <<
<if (is_only)>
only(<dml_table_expression_clause>)
<else>
<dml_table_expression_clause>
<endif>
<if (table_alias)> <table_alias><endif>
>>

values_clause(expression_or_expression_list) ::= <<
values <expression_or_expression_list>
>>

expression_list(expressions) ::= <<
(<expressions; separator=",\n">)
>>

static_returning_clause(expressions, into_clause) ::= <<
returning <expressions; separator=", "> <into_clause>
>>

into_clause(is_bulk_collect, general_elements) ::= <<
<if (is_bulk_collect)>bulk collect <endif>into <general_elements; separator=", ">
>>

exception_clause(exception_handlers) ::= <<
exception
  <exception_handlers; separator="\n">
>>

exception_handler(exception_names, seq_of_statements) ::= <<
when <exception_names; separator=" or ">
then
  <seq_of_statements>
>>

update_statement(general_table_ref, update_set_elements, where_clause, static_returning_clause, error_logging_clause) ::= <<
update <general_table_ref>
set
  <update_set_elements; separator=",\n"><if (where_clause)>
  
<where_clause>
<endif><if (static_returning_clause)>

<static_returning_clause>
<endif><if (error_logging_clause)>

<error_logging_clause>
<endif>
>>

update_set_element_column_expr(column_name, expression) ::= <<
<column_name> = <expression>
>>

update_set_element_columns_subquery(column_names, subquery) ::= <<
(<column_names; separator=", ">) = <subquery>
>>

update_set_element_column_value(column_name, expression) ::= <<
value(<column_name>) = <expression>
>>

if_statement(condition, then_seq_of_statements, elsif_parts, else_part) ::= <<
if <condition> then
  <then_seq_of_statements><if (elsif_parts)>
  
<elsif_parts; separator="\n">
<endif><if (else_part)>

<else_part>
<endif>

end if
>>

elsif_part(condition, seq_of_statements) ::= <<
elsif <condition> then
  <seq_of_statements>
>>

else_part(seq_of_statements) ::= <<
else
  <seq_of_statements>
>>

delete_statement(general_table_ref, where_clause, static_returning_clause, error_logging_clause) ::= <<
delete from <general_table_ref><if (where_clause)>

<where_clause>
<endif><if (static_returning_clause)>

<static_returning_clause>
<endif><if (error_logging_clause)>

<error_logging_clause>
<endif>
>>

assignment_statement(dst, expression) ::= <<
<dst> := <expression>
>>

hierarchical_query_clause(is_nocycle, condition, start_part) ::= <<
connect by<if (is_nocycle)> nocycle<endif> <condition><if (start_part)> <start_part><endif>
>>

start_part(condition) ::= <<
start with <condition>
>>

group_by_clause(group_by_elements, having_clause) ::= <<
group by <group_by_elements; separator=", "><if (having_clause)>

<having_clause>
<endif>
>>

having_clause(condition) ::= <<
having <condition>
>>
