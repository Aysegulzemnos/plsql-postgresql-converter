group PLSQLPrinterTemplates;

string_literal(val) ::= "<val>"

create_function_body(
  is_create, is_replace, name_parts, arguments,
  return_type, add_clauses, is_pipelined, block
) ::= <<
<if (is_create)>create<if (is_replace)> or replace<endif> <endif>function <name_parts; separator="."><if (arguments)>
  (<arguments; separator=",\n">)<endif>
return <return_type>
<add_clauses; separator=" ">
<if (is_pipelined)>pipelined<endif>

is
<block>
>>

parameter(
  name, is_in, is_out, is_inout, is_nocopy, type, default_value_part
) ::= <<
<name><if (is_in)>
 IN<endif><if (is_out)> OUT<endif><if (is_inout)> IN OUT
<endif><if (is_nocopy)>
 NOCOPY
<endif> <type><if (default_value_part)> <default_value_part><endif>
>>

default_value_part(expression) ::= "default <expression>"

base_type_spec_precision(
  size1, size2, is_byte, is_char
) ::= <<
(<size1><if (is_byte)> byte<elseif (is_char)> char<endif><if (size2)>, <size2><endif>)
<endif>
>>

base_type_spec(
  baseName, precision, is_with_time_zone, is_time_zone_local
) ::= <<
<baseName><precision><if (is_with_time_zone)>
 with<if (is_time_zone_local)> local<endif> time zone
<endif>
>>

body(
  bodyLabel, statements, exception_clause
) ::= <<
begin
  <statements>
<exception_clause>
end<if (bodyLabel)> <bodyLabel><endif>
>>

seq_of_statements(statements) ::= <<
<statements:{statement|<statement>;}; separator="\n">
>>

labeled_statement(name, statement) ::= <<
\<\<<name>\>\>
<statement>
>>

return_statement(expression) ::= "return<if (expression)> <expression><endif>"

null_statement() ::= "null"

case_statement_simple(expression, case_when_parts, case_else_part) ::= <<
case <expression>
  <case_when_parts; separator="\n"><if (case_else_part)>
  
  <case_else_part><endif>
end
>>

case_statement_searched(case_when_parts, case_else_part) ::= <<
case
  <case_when_parts; separator="\n"><if (case_else_part)>
  
  <case_else_part><endif>
end
>>

case_when_part_statements(condition, seq_of_statements) ::= <<
when <condition>
then
  <seq_of_statements>
>>

case_when_part_expression(condition, expression) ::= <<
when <condition> then <expression>
>>

case_else_part_statements(seq_of_statements) ::= <<
else
  <seq_of_statements>
>>

case_else_part_expression(expression) ::= <<
else <expression>
>>

general_element(parts) ::= "<parts>"

function_argument(valueExpr, name) ::= "<if (name)><name> => <endif><valueExpr>"

function_arguments(arguments) ::= <<
(<arguments; separator=", ">)
>>

expression_element_generic_binop(op, arg1, arg2) ::= "(<arg1>) <op> (<arg2>)"
expression_element_generic_suffix_unary_op(op, arg) ::= "(<arg>) <op>"
expression_element_generic_prefix_unary_op(op, is_spaced, arg) ::= "<op><if (is_spaced)> <endif>(<arg>)"
expression_element_cursor_op(cursor_name, op) ::= "<cursor_name><op>"
expression_element_in(expr, in_elements) ::= "<expr> in <in_elements>"
expression_element_not_in(expr, in_elements) ::= "<expr> not in <in_elements>"
expression_element_prior(expr) ::= "prior <expr>"
expression_element_dot_star(tableview_name) ::= "<tableview_name>.*"
expression_element_like(text, like_op, pattern, escape_char) ::= <<
(<text>) <like_op> (<pattern>)<if (escape_char)> escape (<escape_char>)<endif>
>>
expression_element_not(expr) ::= "not(<expr>)"
expression_element_outer_join_sign(expr) ::= "<expr>(+)"
expression_element_quantified_expr(subquery_or_expression, is_some, is_any, is_all, is_exists) ::= <<
<if (is_some)>some<elseif (is_any)>any<elseif (is_all)>all<elseif (is_exists)>exists<endif>(<subquery_or_expression>)
>>
expression_element_between(expr, is_not, expr_low, expr_high) ::= <<
<expr> <if (is_not)>not <endif>between <expr_low> and <expr_high>
>>

standard_function_count(is_distinct, is_unique, is_all, is_asterisk, expression, over_clause) ::= <<
count(<if (is_distinct)>
distinct <elseif(is_unique)>unique <elseif(is_all)>all <endif><if (is_asterisk)>*<else><expression>
<endif>)<if (over_clause)> <over_clause><endif>
>>

standard_function_enabling_over(function_name, function_arguments, over_clause) ::= <<
<function_name><function_arguments><if (over_clause)> <over_clause><endif>
>>

standard_function_cast(subquery_or_expression, type_spec) ::= <<
cast(<subquery_or_expression> as <type_spec>)
>>

standard_function_xmlcast(expression, type_spec) ::= <<
cast(<expression> as <type_spec>)
>>

for_loop(loopDefinition, statements) ::= <<
for <loopDefinition> loop
  <statements>
end loop
>>

loopDefinition_bounds(indexVar, isReverse, lowerBound, upperBound) ::= <<
<indexVar> in<if (isReverse)> reverse<endif> <lowerBound>..<upperBound>
>>

loopDefinition_select(indexVar, select_statement) ::= <<
<indexVar> in
(
  <select_statement>
)
>>

while_loop(condition, seq_of_statements) ::= <<
while <condition> loop
  <seq_of_statements>
end loop
>>

loop(seq_of_statements) ::= <<
loop
  <seq_of_statements>
end loop
>>

select_statement(query_partitioning_clause, subquery, order_by_clause, for_update_clause) ::= <<
<if (query_partitioning_clause)><query_partitioning_clause><endif>
<subquery><if (order_by_clause)>

<order_by_clause>
<endif>
<if (for_update_clause)>

<for_update_clause>
<endif>
>>

subquery(subquery_basic_elements, subquery_operation_parts) ::= <<
<subquery_basic_elements>
<if (subquery_operation_parts)>
<subquery_operation_parts; separator="\n">
<endif>
>>

subquery_operation_part(operator, is_all, subquery_basic_elements) ::= <<
<operator><if (is_all)> all<endif> <subquery_basic_elements>
>>

in_parens(val) ::= "(<val>)"

query_block(
  is_distinct, is_unique, is_all, is_asterisk, selected_elements,
  into_clause, from_clause, where_clause, hierarchical_query_clause, group_by_clause, model_clause
) ::= <<
select <if (is_distinct)>
distinct 
<elseif (is_unique)>
unique
<elseif (is_all)>
all
<endif>
<if (is_asterisk)>
*
<else>
<selected_elements; separator=",\n  ">
<endif>
<if (into_clause)>

<into_clause>
<endif>

<from_clause><if (where_clause)>

<where_clause>
<endif><if (hierarchical_query_clause)>

<hierarchical_query_clause>
<endif><if (group_by_clause)>

<group_by_clause>
<endif><if (model_clause)>

<model_clause>
<endif>
>>

column_alias(name) ::= "as <name>"
table_alias(name) ::= "<name>"

selected_element(expression, alias) ::= "<expression><if (alias)> <alias><endif>"

from_clause(table_refs) ::= <<
from <table_refs; separator=",\n  ">
>>

table_ref(table_ref_aux, join_clauses) ::= <<
<table_ref_aux><if (join_clauses)>

<join_clauses; separator="\n">
<endif>
>>

join_clause(qpc1, is_cross, is_natural, is_inner, is_left, is_right, is_full, table_ref_aux, qpc2, join_on_part, join_using_part) ::= <<
<if (qpc1)>
<qpc1>
<endif>
<if (is_cross)>
cross
<else>
<if (is_natural)>
natural
<endif>
<if (is_inner)>
inner
<elseif (is_left)>
left
<elseif (is_right)>
right
<elseif (is_full)>
full
<endif>
<endif>
join <table_ref_aux> <if (qpc2)>
<qpc2>
<endif>
<if (join_on_part)><join_on_part><else><join_using_part><endif>
>>

table_ref_aux(is_only, dml_table_expression_clause, pivot_clause, unpivot_clause, flashback_query_clause, alias) ::= <<
<if (is_only)>
only(<dml_table_expression_clause>)
<else>
<dml_table_expression_clause><if (pivot_clause)> <pivot_clause><elseif (unpivot_clause)> <unpivot_clause><endif>
<endif><if (flashback_query_clause)> <flashback_query_clause><endif><if (alias)> <alias><endif>
>>

dml_table_expression_clause_direct(table_or_view_name, sample_clause) ::= <<
<table_or_view_name><if (sample_clause)> <sample_clause><endif>
>>

tableview_name(ids, link_name, partition_extension_clause) ::= <<
<ids; separator="."><if (link_name)>@<link_name><endif><if (partition_extension_clause)><partition_extension_clause><endif>
>>

dml_table_expression_clause_select(select_statement, subquery_restriction_clause) ::= <<
(<select_statement><if (subquery_restriction_clause)>

<subquery_restriction_clause>
<endif>)
>>

join_on_part(expression) ::= "on <expression>"

where_clause(expression) ::= "where <expression>"

order_by_clause(is_siblings, elements) ::= <<
order<if (is_siblings)> siblings<endif> by <elements; separator=", ">
>>

order_by_elements(expression, is_asc, is_desc, is_nulls_first, is_nulls_last) ::= <<
<expression><if (is_asc)> asc<elseif (is_desc)> desc<endif><if (is_nulls_first)> nulls first<elseif (is_nulls_last)> nulls last<endif>
>>

for_update_clause(for_update_of_part, for_update_options) ::= <<
for update<if (for_update_of_part)> <for_update_of_part><endif><if (for_update_options)> <for_update_options><endif>
>>

for_update_of_part(column_names) ::= <<
of <column_names; separator=",">
>>

for_update_options_skip_locked() ::= "skip locked"
for_update_options_nowait() ::= "nowait"
for_update_options_wait(expression) ::= "wait <expression>"

create_package_spec(is_replace, name, invoker_rights_clause, items) ::= <<
create<if (is_replace)> or replace<endif> package <name><if (invoker_rights_clause)>

<invoker_rights_clause>
<endif>

is
  <items; separator="\n\n">
end;
>>

dotted_name(ids) ::= <<
<ids; separator=".">
>>

procedure_spec(name, arguments) ::= <<
procedure <name><if (arguments)>(
  <arguments; separator=",\n">)<endif>;
>>

function_spec(name, arguments, return_type, is_pipelined, is_result_cache, is_deterministic) ::= <<
function <name><if (arguments)>(
  <arguments; separator=",\n">)<endif>
return <return_type><if (is_pipelined)> pipelined<endif><if (is_result_cache)> result_cache<endif><if (is_deterministic)> deterministic<endif>;
>>

typespec_custom(name, is_ref, is_percent_rowtype, is_percent_type) ::= <<
<if (is_ref)>ref <endif><name><if (is_percent_rowtype)>%rowtype<elseif (is_percent_type)>%type<endif>
>>

create_package_body(is_replace, name, items, init_section_seq_of_statements, init_section_exception_clause) ::= <<
create<if (is_replace)> or replace<endif> package body <name>
is
  <items; separator="\n\n"><if (init_section_seq_of_statements)>

begin
  <init_section_seq_of_statements>
<init_section_exception_clause>
<endif>

end;
>>

create_procedure_body(is_create, is_replace, name, arguments, invoker_rights_clause, impl) ::= <<
<if (is_create)>create<if (is_replace)> or replace<endif> <endif>procedure <name><if (arguments)>(
  <arguments; separator=",\n">)<endif><if (invoker_rights_clause)>

<invoker_rights_clause>
<endif>

is
<impl>
>>

create_procedure_body_impl_external() ::= "external"

block(declare_spec, body) ::= <<
<if (declare_spec)>
declare
  <declare_spec:{v|<v>
}>
<endif>
<body>;
>>

variable_declaration(name, type, is_constant, is_not_null, default_value_part) ::= <<
<name><if (is_constant)> constant<endif> <type><if (is_not_null)> not null<endif><if (default_value_part)> <default_value_part><endif>;
>>

table_type_dec(name, impl) ::= <<
type <name> is <impl>;
>>

varray_type_def(limit_expression, element_type, is_not_null) ::= <<
varray(<limit_expression>) of <element_type><if (is_not_null)> not null<endif>
>>

table_type_dec_table_of(type_spec, table_indexed_by_part, is_not_null) ::= <<
table of <type_spec><if (table_indexed_by_part)> <table_indexed_by_part><endif><if (is_not_null)> not null<endif>
>>

table_indexed_by_part(type_spec) ::= <<
indexed by <type_spec>
>>

subtype_declaration(name, type_spec, range, is_not_null) ::= <<
subtype <name> is <type_spec><if (range)> <range><endif><if (is_not_null)> not null<endif>;
>>

subtype_range(low_bound, high_bound) ::= <<
range <low_bound>..<high_bound>
>>
    
record_type_dec_record(name, field_specs) ::= <<
type <name> is record (
  <field_specs; separator=",\n">);
>>
    
record_type_dec_refcursor(name, type_spec) ::= <<
type <name> is ref cursor<if (type_spec)> return <type_spec><endif>;
>>

field_spec(name, type_spec, is_not_null, default_value_part) ::= <<
<name><if (type_spec)> <type_spec><endif><if (is_not_null)> not null<endif><if (default_value_part)> <default_value_part><endif>
>>

pragma_declaration(impl) ::= "pragma <impl>;"

pragma_declaration_impl_serially_reusable() ::= "serially_reusable"
pragma_declaration_impl_serially_autonomous_transaction() ::= "autonomous_transaction"
pragma_declaration_impl_serially_exception_init(name, numeric) ::= "exception_init (<name>, <numeric>)"
pragma_declaration_impl_serially_inline(id, expression) ::= "inline (<id>, <expression>)"
pragma_declaration_impl_serially_restrict_references(arg1, restArgs) ::= <<
restrict_references (<arg1><restArgs:{v|, <v>}>)
>>

single_table_insert(insert_into_clause, values_clause, static_returning_clause, select_statement, error_logging_clause) ::= <<
insert <insert_into_clause>
<if (values_clause)>
<values_clause><if (static_returning_clause)>

<static_returning_clause>
<endif>
<else>
<select_statement>
<endif><if (error_logging_clause)>

<error_logging_clause>
<endif>
>>

insert_into_clause(general_table_ref, columns) ::= <<
into <general_table_ref><if (columns)>(<columns; separator=", ">)<endif>
>>

general_table_ref(is_only, dml_table_expression_clause, table_alias) ::= <<
<if (is_only)>
only(<dml_table_expression_clause>)
<else>
<dml_table_expression_clause>
<endif>
<if (table_alias)> <table_alias><endif>
>>

values_clause(expression_or_expression_list) ::= <<
values <expression_or_expression_list>
>>

expression_list(expressions) ::= <<
(<expressions; separator=",\n">)
>>

static_returning_clause(expressions, into_clause) ::= <<
returning <expressions; separator=", "> <into_clause>
>>

into_clause(is_bulk_collect, general_elements) ::= <<
<if (is_bulk_collect)>bulk collect <endif>into <general_elements; separator=", ">
>>

exception_clause(exception_handlers) ::= <<
exception
  <exception_handlers; separator="\n">
>>

exception_handler(exception_names, seq_of_statements) ::= <<
when <exception_names; separator=" or ">
then
  <seq_of_statements>
>>

update_statement(general_table_ref, update_set_elements, where_clause, static_returning_clause, error_logging_clause) ::= <<
update <general_table_ref>
set
  <update_set_elements; separator=",\n"><if (where_clause)>
  
<where_clause>
<endif><if (static_returning_clause)>

<static_returning_clause>
<endif><if (error_logging_clause)>

<error_logging_clause>
<endif>
>>

update_set_element_column_expr(column_name, expression) ::= <<
<column_name> = <expression>
>>

update_set_element_columns_subquery(column_names, subquery) ::= <<
(<column_names; separator=", ">) = <subquery>
>>

update_set_element_column_value(column_name, expression) ::= <<
value(<column_name>) = <expression>
>>

if_statement(condition, then_seq_of_statements, elsif_parts, else_part) ::= <<
if <condition> then
  <then_seq_of_statements><if (elsif_parts)>
  
<elsif_parts; separator="\n">
<endif><if (else_part)>

<else_part>
<endif>

end if
>>

elsif_part(condition, seq_of_statements) ::= <<
elsif <condition> then
  <seq_of_statements>
>>

else_part(seq_of_statements) ::= <<
else
  <seq_of_statements>
>>

delete_statement(general_table_ref, where_clause, static_returning_clause, error_logging_clause) ::= <<
delete from <general_table_ref><if (where_clause)>

<where_clause>
<endif><if (static_returning_clause)>

<static_returning_clause>
<endif><if (error_logging_clause)>

<error_logging_clause>
<endif>
>>

assignment_statement(dst, expression) ::= <<
<dst> := <expression>
>>

hierarchical_query_clause(is_nocycle, condition, start_part) ::= <<
connect by<if (is_nocycle)> nocycle<endif> <condition><if (start_part)> <start_part><endif>
>>

start_part(condition) ::= <<
start with <condition>
>>

group_by_clause(group_by_elements, having_clause) ::= <<
group by <group_by_elements; separator=", "><if (having_clause)>

<having_clause>
<endif>
>>

having_clause(condition) ::= <<
having <condition>
>>

table_collection_expression(expression_or_subquery, is_outer_join) ::= <<
table (<expression_or_subquery>)<if (is_outer_join)>(+)<endif>
>>

close_statement(cursor_name) ::= "close <cursor_name>"
open_statement(cursor_name, expression_list) ::= "open <cursor_name><expression_list>"

fetch_statement(cursor_name, into_clause) ::= <<
fetch <cursor_name> <into_clause>
>>

open_for_statement(cursor_name, expression_or_select_statement, using_clause) ::= <<
open <cursor_name> for <expression_or_select_statement><if (using_clause)>

<using_clause>
<endif>
>>

using_clause(using_elements) ::= <<
using <using_elements; separator=", ">
>>

using_element_asterisk() ::= "*"

using_element_element(is_in, is_out, expression, alias) ::= <<
<if (is_in)>in <endif><if (is_out)>out <endif><expression><if (alias)> <alias><endif>
>>

over_clause(query_partition_clause, order_by_clause, windowing_clause) ::= <<
over (<if (query_partition_clause)><query_partition_clause> <endif><if (order_by_clause)><order_by_clause><if (windowing_clause)> <windowing_clause><endif><endif>)
>>

exit_statement(label_name, condition) ::= <<
exit<if (label_name)> <label_name><endif><if (condition)> <condition><endif>
>>

continue_statement(label_name, condition) ::= <<
continue<if (label_name)> <label_name><endif><if (condition)> <condition><endif>
>>

general_when(expression) ::= "when <expression>"

execute_immediate_statement(expression, into_clause, using_clause, dynamic_returning_clause) ::= <<
execute immediate <expression><if (into_clause)>

<into_clause>
<endif><if (using_clause)>

<using_clause>
<endif><if (dynamic_returning_clause)>

<dynamic_returning_clause>
<endif>
>>

dynamic_returning_clause(into_clause) ::= "returning <into_clause>"

commit_statement(is_work, additional) ::= "commit<if (is_work)> work<endif><if (additional)> <additional><endif>"

commit_comment(comment_expression, write_clause) ::= <<
comment <comment_expression><if (write_clause)> <write_clause><endif>
>>

commit_statement_write_clause(is_wait, is_nowait, is_immediate, is_batch) ::= <<
write<if (is_wait)> wait<elseif (is_nowait)> nowait<endif><if (is_immediate)> immediate<elseif (is_batch)> batch<endif>
>>

commit_statement_force_1(expr1, expr2) ::= <<
force <expr1><if (expr2)>, <expr2><endif>
>>

commit_statement_force_2(expression) ::= <<
force corrupt_xid <expression>
>>

commit_statement_force_3() ::= <<
force corrupt_xid_all
>>

raise_statement(name) ::= "raise<if(name)> <name><endif>"

query_partition_clause(impl) ::= "partition by <impl>"
query_partition_clause_impl_expressions(expressions) ::= <<
<expressions; separator=", ">
>>

xmltable(xml_namespaces_clause, xquery_expression, xml_passing_clause, xml_table_columns) ::= <<
xmltable(<if (xml_namespaces_clause)>
<xml_namespaces_clause> <endif><xquery_expression><if (xml_passing_clause)> <xml_passing_clause>
<endif>
<if (xml_table_columns)> columns <xml_table_columns; separator=", "><endif>)
>>

xml_passing_clause(is_by_value, xml_passing_clause_expressions) ::= <<
passing<if (is_by_value)> by value<endif> <xml_passing_clause_expressions; separator=", ">
>>

xml_passing_clause_expr(expression, alias) ::= <<
<expression><if (alias)> <alias><endif>
>>

xml_table_column_ordinality(name) ::= <<
<name> for ordinality
>>

xml_table_column_typespec(name, type_spec, path_expr, xml_general_default_part) ::= <<
<name> <type_spec><if (path_expr)> path <path_expr><endif><if (xml_general_default_part)> <xml_general_default_part><endif>
>>

xml_general_default_part(expression) ::= <<
default <expression>
>>

xml_parse(is_document, is_content, expression, is_wellformed) ::= <<
xmlparse(<if (is_document)>document<elseif (is_content)>content><endif> <expression><if (is_wellformed)> wellformed<endif>)
>>

interval_type_spec(left_side, right_side) ::= <<
interval <left_side> to <right_side>
>>

interval_type_spec_first(is_year, is_day, expression) ::= <<
<if (is_year)>year<elseif (is_day)>day<endif><if (expression)>(<expression>)<endif>
>>

interval_type_spec_second(is_month, is_second, expression) ::= <<
<if (is_month)>month<elseif (is_second)>second<endif><if (expression)>(<expression>)<endif>
>>