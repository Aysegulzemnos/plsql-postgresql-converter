group PLSQLPrinterTemplates;

string_literal(val) ::= "<val>"

create_function_body(
  is_replace, name_parts, arguments,
  return_type, add_clauses, is_pipelined, block
) ::= <<
create<if (is_replace)> or replace<endif> function <name_parts; separator="."><if (arguments)>
  (<arguments; separator=",\n">)<endif>
return <return_type>
<add_clauses; separator=" ">
<if (is_pipelined)>pipelined<endif>
as
<block>;
>>

parameter(
  name, is_in, is_out, is_inout, is_nocopy, type, default_value_part
) ::= <<
<name><if (is_in)>
 IN<endif><if (is_out)> OUT<endif><if (is_inout)> IN OUT
<endif><if (is_nocopy)>
 NOCOPY
<endif> <type><if (default_value_part)> <default_value_part><endif>
>>

default_value_part(expression) ::= "default <expression>"

base_type_spec_precision(
  size1, size2, is_byte, is_char
) ::= <<
(<size1><if (is_byte)> byte<elseif (is_char)> char<endif><if (size2)>, <size2><endif>)
<endif>
>>

base_type_spec(
  baseName, precision, is_with_time_zone, is_time_zone_local
) ::= <<
<baseName><precision><if (is_with_time_zone)>
 with<if (is_time_zone_local)> local<endif> time zone
<endif>
>>

body(
  bodyLabel, statements, exception_clause
) ::= <<
begin
  <statements>
<exception_clause>
end<if (bodyLabel)> <bodyLabel><endif>
>>

seq_of_statements(statements) ::= <<
<statements:{statement|<statement>;}; separator="\n">
>>

labeled_statement(name, statement) ::= <<
\<\<<name>\>\>
<statement>
>>

return_statement(expression) ::= "return<if (expression)> <expression><endif>"

general_element(parts) ::= "<parts>"

function_argument(valueExpr, name) ::= "<if (name)><name> => <endif><valueExpr>"

function_arguments(arguments) ::= <<
(<arguments; separator=", ">)
>>

expression_element_generic_binop(op, arg1, arg2) ::= "(<arg1>) <op> (<arg2>)"

for_loop(loopDefinition, statements) ::= <<
for <loopDefinition> loop
  <statements>
end loop
>>

loopDefinition_bounds(indexVar, isReverse, lowerBound, upperBound) ::= <<
<indexVar> in<if (isReverse)> reverse<endif> <lowerBound>..<upperBound>
>>

select_statement(query_partitioning_clause, subquery, order_by_clause, for_update_clause) ::= <<
<if (query_partitioning_clause)><query_partitioning_clause><endif>
<subquery><if (order_by_clause)>

<order_by_clause>
<endif>
<if (for_update_clause)>

<for_update_clause>
<endif>
>>

subquery(subquery_basic_elements, subquery_operation_parts) ::= <<
<subquery_basic_elements><if (subquery_operation_parts)>
<subquery_operation_parts; separator="\n">
<endif>
>>

subquery_operation_part(operator, is_all, subquery_basic_elements) ::= <<
<operator><if (is_all)> all<endif>
<subquery_basic_elements>
>>

in_parens(val) ::= "(<val>)"

query_block(
  is_distinct, is_unique, is_all, is_asterisk, selected_elements,
  into_clause, from_clause, where_clause, hierarchical_query_clause, group_by_clause, model_clause
) ::= <<
select <if (is_distinct)>
distinct 
<elseif (is_unique)>
unique
<elseif (is_all)>
all
<endif>
<if (is_asterisk)>
*
<else>
<selected_elements; separator=",\n  ">
<endif>
<if (into_clause)>
<into_clause>
<endif>

<from_clause><if (where_clause)>

<where_clause>
<endif><if (hierarchical_query_clause)>

<hierarchical_query_clause>
<endif><if (group_by_clause)>

<group_by_clause>
<endif><if (model_clause)>

<model_clause>
<endif>
>>

alias(name) ::= "as <name>"

selected_element(expression, alias) ::= "<expression><alias>"

from_clause(table_refs) ::= <<
from <table_refs; separator=",\n  ">
>>

table_ref(table_ref_aux, join_clauses) ::= <<
<table_ref_aux><if (join_clauses)>

<join_clauses; separator="\n">
<endif>
>>

join_clause(qpc1, is_cross, is_natural, is_inner, is_left, is_right, is_full, table_ref_aux, qpc2, join_on_part, join_using_part) ::= <<
<if (qpc1)>
<qpc1>
<endif>
<if (is_cross)>
cross
<else>
<if (is_natural)>
natural
<endif>
<if (is_inner)>
inner
<elseif (is_left)>
left
<elseif (is_right)>
right
<elseif (is_full)>
full
<endif>
<endif>
join <table_ref_aux> <if (qpc2)>
<qpc2>
<endif>
<if (join_on_part)><join_on_part><else><join_using_part><endif>
>>

table_ref_aux(is_only, dml_table_expression_clause, pivot_clause, unpivot_clause, flashback_query_clause, alias) ::= <<
<if (is_only)>
only(<dml_table_expression_clause>)
<else>
<dml_table_expression_clause><if (pivot_clause)> <pivot_clause><elseif (unpivot_clause)> <unpivot_clause><endif>
<endif><if (flashback_query_clause)> <flashback_query_clause><endif><if (alias)> <alias><endif>
>>

dml_table_expression_clause_direct(table_or_view_name, sample_clause) ::= <<
<table_or_view_name><if (sample_clause)> <sample_clause><endif>
>>

tableview_name(ids, link_name, partition_extension_clause) ::= <<
<ids; separator="."><if (link_name)>@<link_name><endif><if (partition_extension_clause)><partition_extension_clause><endif>
>>

join_on_part(expression) ::= "on <expression>"

where_clause(expression) ::= "where <expression>"

order_by_clause(is_siblings, elements) ::= <<
order<if (is_siblings)> siblings<endif> by <elements; separator=", ">
>>

order_by_elements(expression, is_asc, is_desc, is_nulls_first, is_nulls_last) ::= <<
<expression><if (is_asc)> asc<elseif (is_desc)> desc<endif><if (is_nulls_first)> nulls first<elseif (is_nulls_last)> nulls last<endif>
>>

create_package_spec(is_replace, name, invoker_rights_clause, items) ::= <<
create<if (is_replace)> or replace<endif> package <name><if (invoker_rights_clause)>

<invoker_rights_clause>
<endif>

is
  <items; separator="\n\n">
end;
>>

dotted_name(ids) ::= <<
<ids; separator=".">
>>

procedure_spec(name, arguments) ::= <<
procedure <name><if (arguments)>(
  <arguments; separator=",\n">)<endif>;
>>

function_spec(name, arguments, return_type, is_pipelined, is_result_cache, is_deterministic) ::= <<
function <name><if (arguments)>(
  <arguments; separator=",\n">)<endif>
return <return_type><if (is_pipelined)> pipelined<endif><if (is_result_cache)> result_cache<endif><if (is_deterministic)> deterministic<endif>;
>>

typespec_custom(name, is_ref, is_percent_rowtype, is_percent_type) ::= <<
<if (is_ref)>ref <endif><name><if (is_percent_rowtype)>%rowtype<elseif (is_percent_type)>%type<endif>
>>

create_package_body(is_replace, name, items, init_section_seq_of_statements, init_section_exception_clause) ::= <<
create<if (is_replace)> or replace<endif> package body <name>
is
  <items; separator="\n\n"><if (init_section_seq_of_statements)>

begin
  <init_section_seq_of_statements>
<init_section_exception_clause>
<endif>

end <name>;
>>

create_procedure_body(is_replace, name, arguments, invoker_rights_clause, impl) ::= <<
create<if (is_replace)> or replace<endif> procedure <name><if (arguments)>(
  <arguments; separator=",\n">)<endif><if (invoker_rights_clause)>

<invoker_rights_clause>
<endif>
is
<impl>
>>

create_procedure_body_impl_external() ::= "external"

block(declare_spec, body) ::= <<
<if (declare_spec)>
declare
  <declare_spec:{v|<v>;
}>
<endif>
<body>;
>>

variable_declaration(name, type, is_constant, is_not_null, default_value_part) ::= <<
<name><if (is_constant)> constant<endif> <type><if (is_not_null)> not null<endif><if (default_value_part)> <default_value_part><endif>;
>>

table_type_dec(name, impl) ::= <<
type <name> is <impl>;
>>

varray_type_def(limit_expression, element_type, is_not_null) ::= <<
varray(<limit_expression>) of <element_type><if (is_not_null)> not null<endif>
>>

table_type_dec_table_of(type_spec, table_indexed_by_part, is_not_null) ::= <<
table of <type_spec><if (table_indexed_by_part)> <table_indexed_by_part><endif><if (is_not_null)> not null<endif>
>>

table_indexed_by_part(type_spec) ::= <<
indexed by <type_spec>
>>

subtype_declaration(name, type_spec, range, is_not_null) ::= <<
subtype <name> is <type_spec><if (range)> <range><endif><if (is_not_null)> not null<endif>;
>>

subtype_range(low_bound, high_bound) ::= <<
range <low_bound>..<high_bound>
>>