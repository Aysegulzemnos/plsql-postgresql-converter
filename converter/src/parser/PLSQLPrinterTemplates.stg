group PLSQLPrinterTemplates;

string_literal(val) ::= "<val>"

create_function_body(
  is_replace, name_parts, arguments,
  return_type, add_clauses, is_pipelined, body
) ::= <<
create <if (is_replace)>or replace<endif> function <name_parts; separator=".">
<if (arguments)>(<arguments; separator=",\n">)<endif>
return <return_type>
<add_clauses; separator=" ">
<if (is_pipelined)>pipelined<endif>
as
<body>;
>>

parameter(
  name, is_in, is_out, is_inout, is_nocopy, type
) ::= <<
<name> <if (is_in)> IN<elseif (is_out)> OUT<elseif (is_inout)> IN OUT<endif> <if (is_nocopy)> NOCOPY<endif> <type>
>>

base_type_spec_precision(
  size1, size2, is_byte, is_char
) ::= <<
(<size1><if (is_byte)>byte<elseif (is_char)>char<endif><if (size2)>, <size2><endif>)
<endif>
>>

base_type_spec(
  baseName, precision, is_with_time_zone, is_time_zone_local
) ::= <<
<baseName> <precision> <if (is_with_time_zone)>
with <if (is_time_zone_local)>local<endif> time zone
<endif>
>>

body(
  bodyLabel, statements, exception_clause
) ::= <<
begin
  <statements>
<exception_clause>
end<if (bodyLabel)> <bodyLabel><endif>
>>

seq_of_statements(statements) ::= <<
<statements:{statement|<statement>;
}>
>>

label_declaration(name) ::= "\<\<<name>\>\>"

return_statement(expression) ::= "return<if (expression)> <expression><endif>"

general_element(parts) ::= "<parts>"

function_argument(valueExpr, name) ::= "<if (name)><name> => <endif><valueExpr>"

function_arguments(arguments) ::= <<
(<arguments; separator=", ">)
>>

expression_element_generic_binop(op, arg1, arg2) ::= "(<arg1>) <op> (<arg2>)"